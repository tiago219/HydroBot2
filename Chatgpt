https://chatgpt.com/share/68b9cddf-7bb8-800d-83c2-cdaedd87c674

PS K:\Users\20231350250\Documents\mibr2025\hydrobot-app> npm i @react-native-webview/webview
npm error code E404
npm error 404 Not Found - GET https://registry.npmjs.org/@react-native-webview%2fwebview - Not found
npm error 404
npm error 404  '@react-native-webview/webview@*' is not in this registry.
npm error 404
npm error 404 Note that you can also install from a
npm error 404 tarball, folder, http url, or git url.
npm error A complete log of this run can be found in: K:\Users\20231350250\AppData\Local\npm-cache\_logs\2025-09-03T22_33_35_545Z-debug-0.log


Perfeito üôå

Ent√£o aqui vai a √°rvore de arquivos final do seu projeto Expo (sem sensores, apenas c√¢mera + LED + bomba + modos + joystick).



üìÇ Estrutura esperada


hydrobot-app/
‚îú‚îÄ app.json
‚îú‚îÄ package.json
‚îú‚îÄ App.tsx
‚îî‚îÄ src/
   ‚îî‚îÄ config.js




üìÑ Arquivos completos


1. app.json


{
  "expo": {
    "name": "HydroBot",
    "slug": "hydrobot-app",
    "scheme": "hydrobot",
    "version": "1.0.0",
    "orientation": "portrait",
    "sdkVersion": "51.0.0",
    "platforms": ["ios", "android"],
    "userInterfaceStyle": "light"
  }
}




2. package.json


{
  "name": "hydrobot-app",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "private": true,
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "expo": "^51.0.0",
    "expo-status-bar": "~1.12.1",
    "react": "18.2.0",
    "react-native": "0.74.0",
    "react-native-webview": "^13.8.6"
  }
}




3. src/config.js


// IP do ESP32-CAM em modo Access Point
export const BASE_URL = "http://192.168.4.1";




4. App.tsx


import React, { useEffect, useMemo, useRef, useState } from "react";
import { SafeAreaView, View, Text, TouchableOpacity, StyleSheet, ScrollView, TextInput, Alert, PanResponder } from "react-native";
import { WebView } from "react-native-webview";
import { BASE_URL } from "./src/config";

export default function App() {
  const [mode, setMode] = useState("manual");
  const [led, setLed] = useState(false);
  const [pump, setPump] = useState(false);
  const [duty, setDuty] = useState("0");

  const getJson = async (path: string) => (await fetch(`${BASE_URL}${path}`)).json();

  const refresh = async () => {
    try {
      const st = await getJson("/status");
      setMode(st.mode);
      setLed(!!st.led);
      setPump(!!st.pump);
    } catch {}
  };

  useEffect(() => {
    const id = setInterval(refresh, 1000);
    refresh();
    return () => clearInterval(id);
  }, []);

  const toggleLed = async () => {
    const on = !led;
    const r = await getJson(`/led?on=${on ? 1 : 0}`);
    setLed(!!r.led);
  };

  const togglePump = async () => {
    const on = !pump;
    const r = await getJson(`/pump?on=${on ? 1 : 0}`);
    setPump(!!r.pump);
  };

  const applyDuty = async () => {
    const val = Math.max(0, Math.min(255, parseInt(duty || "0", 10)));
    const r = await getJson(`/pump_pwm?duty=${val}`);
    if (r?.ok) {
      Alert.alert("PWM aplicado", `Duty = ${val}`);
      setPump(val > 0);
    } else {
      Alert.alert("Erro", "Duty deve ser 0..255");
    }
  };

  const setModeRemote = async (m: string) => {
    const r = await getJson(`/mode?v=${m}`);
    if (r?.ok) setMode(m);
  };

  // ===== JOYSTICK =====
  const [joy, setJoy] = useState({ x: 0, y: 0 });
  const center = useRef({ x: 0, y: 0 });
  const pan = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onPanResponderGrant: (_, g) => {
          center.current = { x: g.x0, y: g.y0 };
        },
        onPanResponderMove: (_, g) => {
          const dx = g.moveX - center.current.x;
          const dy = g.moveY - center.current.y;
          const nx = Math.max(-1, Math.min(1, dx / 80));
          const ny = Math.max(-1, Math.min(1, -dy / 80));
          setJoy({ x: nx, y: ny });
        },
        onPanResponderRelease: async () => {
          setJoy({ x: 0, y: 0 });
          await getJson(`/joystick?x=0&y=0`);
        }
      }),
    []
  );

  useEffect(() => {
    const id = setTimeout(() => {
      fetch(`${BASE_URL}/joystick?x=${joy.x.toFixed(2)}&y=${joy.y.toFixed(2)}`).catch(() => {});
    }, 60);
    return () => clearTimeout(id);
  }, [joy]);

  const streamHtml = `
    <html><body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">
      <img src="${BASE_URL}:81/stream" style="width:100%;height:100%;object-fit:contain;" />
    </body></html>
  `;

  return (
    <SafeAreaView style={styles.safe}>
      <ScrollView contentContainerStyle={styles.container}>
        <Text style={styles.title}>HydroBot Controller</Text>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>C√¢mera</Text>
          <View style={{ height: 220, borderRadius: 8, overflow: "hidden", backgroundColor: "#000" }}>
            <WebView originWhitelist={["*"]} source={{ html: streamHtml }} />
          </View>
        </View>

        <View style={styles.row}>
          <View style={[styles.card, { flex: 1, marginRight: 6 }]}>
            <Text style={styles.cardTitle}>LED</Text>
            <TouchableOpacity style={[styles.btn, led ? styles.btnOn : styles.btnOff]} onPress={toggleLed}>
              <Text style={styles.btnText}>{led ? "Desligar" : "Ligar"} LED</Text>
            </TouchableOpacity>
          </View>
          <View style={[styles.card, { flex: 1, marginLeft: 6 }]}>
            <Text style={styles.cardTitle}>Bomba (On/Off)</Text>
            <TouchableOpacity style={[styles.btn, pump ? styles.btnDanger : styles.btnOn]} onPress={togglePump}>
              <Text style={styles.btnText}>{pump ? "Desligar" : "Ligar"} Bomba</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>Bomba (PWM)</Text>
          <View style={styles.row}>
            <TextInput style={styles.input} value={duty} onChangeText={setDuty} keyboardType="numeric" placeholder="0..255" />
            <TouchableOpacity style={[styles.btn, styles.btnOn]} onPress={applyDuty}>
              <Text style={styles.btnText}>Aplicar Duty</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>Modo</Text>
          <View style={styles.row}>
            {["manual", "auto", "patrol"].map((m) => (
              <TouchableOpacity key={m} style={[styles.chip, mode === m && styles.chipActive]} onPress={() => setModeRemote(m)}>
                <Text style={[styles.chipText, mode === m && styles.chipTextActive]}>{m}</Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>Joystick</Text>
          <View style={styles.joyArea} {...pan.panHandlers}>
            <View style={[styles.joyDot, { transform: [{ translateX: joy.x * 80 }, { translateY: -joy.y * 80 }] }]} />
          </View>
          <Text style={styles.mono}>x={joy.x.toFixed(2)}  y={joy.y.toFixed(2)}</Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: { flex: 1, backgroundColor: "#0b1220" },
  container: { padding: 16 },
  title: { color: "#fff", fontSize: 22, fontWeight: "700", marginBottom: 12 },
  card: { backgroundColor: "#121a2b", padding: 12, borderRadius: 12, marginBottom: 12, borderWidth: 1, borderColor: "#1e2a44" },
  cardTitle: { color: "#bcd", fontSize: 16, fontWeight: "700", marginBottom: 8 },
  btn: { paddingVertical: 10, paddingHorizontal: 14, borderRadius: 10, alignItems: "center" },
  btnText: { color: "#fff", fontWeight: "700" },
  btnOn: { backgroundColor: "#2d9f5b" },
  btnOff: { backgroundColor: "#2c5aa0" },
  btnDanger: { backgroundColor: "#c23d3d" },
  row: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  input: { flex: 1, backgroundColor: "#0b1220", color: "#fff", borderWidth: 1, borderColor: "#28406b", borderRadius: 10, paddingHorizontal: 12, marginRight: 8, height: 44 },
  chip: { paddingVertical: 8, paddingHorizontal: 12, borderRadius: 999, backgroundColor: "#0b1220", borderWidth: 1, borderColor: "#2a3e60", marginRight: 8 },
  chipActive: { backgroundColor: "#2a3e60" },
  chipText: { color: "#9fb3d2", fontWeight: "700" },
  chipTextActive: { color: "#fff" },
  joyArea: { height: 180, backgroundColor: "#091427", borderRadius: 12, borderWidth: 1, borderColor: "#1e2a44", alignItems: "center", justifyContent: "center" },
  joyDot: { width: 40, height: 40, borderRadius: 999, backgroundColor: "#5aa9ff" },
  mono: { color: "#9fb3d2", fontFamily: "monospace", marginTop: 6 }
});




üëâ Agora sua pasta est√° 100% clara.

Quer que eu te gere tamb√©m os comandos passo-a-passo desde npx create-expo-app at√© rodar o app no celular?







Perfeito. Vamos fazer uma Dev Build do seu app Expo (Android) e, de brinde, uma Preview Build offline para quando o celular estiver conectado ao AP do ESP32 (sem internet).



‚úÖ O que voc√™ vai ganhar




Dev Build (com expo-dev-client): ideal para desenvolver, abrir pelo QR/Deep Link e usar Fast Refresh. (Requer o celular e o PC na mesma rede com internet durante o desenvolvimento.)


Preview Build (APK offline): roda sem Metro/sem internet ‚Äî perfeito para usar conectado ao HYDROBOT-CAM.






Dica: durante os testes com o ESP32 (sem internet), use Preview APK.

Nas itera√ß√µes de c√≥digo, use a Dev Build no seu Wi-Fi normal.





0) Pr√©-requisitos


No projeto hydrobot-app:


npm i -g eas-cli
eas whoami    # (fa√ßa login, se pedir)




1) Ajustes no app (cleartext + dev client)


Abra seu app.json e garanta isto:


{
  "expo": {
    "name": "HydroBot",
    "slug": "hydrobot-app",
    "scheme": "hydrobot",
    "sdkVersion": "51.0.0",
    "plugins": ["expo-dev-client"],
    "android": {
      "usesCleartextTraffic": true,      // permite HTTP para 192.168.4.1
      "permissions": ["INTERNET"]        // por via das d√∫vidas (Expo j√° inclui)
    }
  }
}



Instale o dev client:


npm i expo-dev-client




2) Configurar perfis de build (eas.json)


Crie (ou edite) eas.json na raiz do projeto:


{
  "cli": { "version": ">= 3.17.0" },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": { "buildType": "apk" }
    },
    "preview": {
      "developmentClient": false,
      "distribution": "internal",
      "android": { "buildType": "apk" }
    },
    "production": {
      "developmentClient": false,
      "distribution": "store"
    }
  },
  "submit": {
    "production": {}
  }
}





development ‚Üí Dev Client (APK)


preview ‚Üí APK offline, com bundle embutido (ideal para AP do ESP)





3) Fazer a Dev Build (APK)


eas build --profile development --platform android



Quando terminar, baixe o .apk que o EAS te fornecer.


Instale no Android (com USB e ADB):


adb install -r path/para/o/app-development.apk



Abrir a Dev Build:




Conecte PC e celular no seu Wi-Fi normal (com internet).


No projeto:

npx expo start --dev-client





No celular, abra o app ‚ÄúHydroBot (Dev)‚Äù. Ele vai pedir para abrir o projeto via link/QR do Metro.


Pronto: Fast Refresh e tudo funcionando.






Se aparecer tela branca ou n√£o achar o bundler: verifique que o celular est√° na mesma rede do PC e que o firewall do Windows n√£o bloqueou a porta do Metro.





4) Fazer a Preview Build (APK offline)


eas build --profile preview --platform android



Instale:


adb install -r path/para/o/app-preview.apk



Agora voc√™ pode:




Sair do seu Wi-Fi


Conectar o celular ao AP do ESP32 (HYDROBOT-CAM)


Abrir o app Preview (n√£o √© o Dev).


Ele vai carregar o bundle embutido e acessar http://192.168.4.1 (conforme seu src/config.js).





5) Checagens importantes






react-native-webview instalado:


npx expo install react-native-webview



Import no App.tsx:


import { WebView } from "react-native-webview";







Endere√ßo do ESP:
src/config.js


export const BASE_URL = "http://192.168.4.1";



(Se voc√™ trocar o IP do AP, ajuste aqui.)






Sem internet no AP do ESP

‚Äì Dev Build n√£o vai conseguir baixar bundle se o celular estiver no AP do ESP. Use a Preview APK para esse cen√°rio.






Cleartext HTTP (Android 9+)

J√° habilitamos "usesCleartextTraffic": true. Sem isso, fetch/WebView para http://192.168.4.1 pode ser bloqueado.







6) Plano B (sem EAS): build local ‚Äúrelease‚Äù com Gradle


Se voc√™ quiser tudo local (precisa Android Studio/SDK):


# gera nativo
npx expo prebuild

# abre android/ via Android Studio (ou use Gradle direto)
cd android
./gradlew assembleRelease



O APK sai em android/app/build/outputs/apk/release/app-release.apk.

Instale com adb install -r .... Isso tamb√©m embute o bundle e roda offline.



7) Atalhos √∫teis




Limpar cache:

expo start -c





Verificar registries:

npm config get registry
npm config set registry https://registry.npmjs.org/





Se o WebView n√£o renderiza:



Confirme react-native-webview instalado.


Teste a URL do stream no Chrome do celular: http://192.168.4.1:81/stream.









Se quiser, eu j√° te deixo aqui um eas.json + app.json exatos com as chaves atuais do seu projeto (copiar/colar). E, se aparecer algum erro de EAS (credenciais Android, Keystore, etc.), me manda a mensagem que eu ajusto o fluxo.


